# -*- coding: utf-8 -*-

# Copyright (C) 2006-2015 ianaré sévi <ianare@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

from __future__ import print_function
import codecs
import os
import platform
import sys
import time

import app
import classes
import shutil1
import utils


class Core():
    """
    Renaming Engine.

    Takes names generated by the preview and applies changes to disc.
    Able to undo renaming operations.
    """
    def __init__(self, MainWindow):
        app.debug_print("loading renamer engine");
        global main
        main = MainWindow

    def _set_display(self, i):
        """Refreshes display and main window during renaming operation."""
        main.bottomWindow.display.EnsureVisible(i)
        main.bottomWindow.display.Refresh()
        main.Update()

    def _show_rename_error(self, i, err, original, renamed):
        """Show renaming errors."""
        err = err.decode(sys.getfilesystemencoding())
        # set item as bad
        main.toRename[i][1][1] = None
        self._set_display(i)
        # show error message
        main.set_status_msg(_("Renaming Failed : %s") % err, u'failed')
        utils.make_err_msg(_(u"Error renaming:\n%s \n\nto:\n%s \n\nReason: %s")\
                           % (original[0], renamed[0], err),
                           _(u"Renaming Failed !!"))

    def _rename_item(self, i, original, renamed, refresh_int):
        """
        Renaming operation, with recursive error handling.

        Returns False on success.
        """
        try:
            shutil1.move(original[0], renamed[0], True)
        except IOError as error:
            errNumb = error.errno
            err = error.strerror
            app.debug_print("IOError : %s, %s" % (errNumb, err))
            # may need to create dirs first
            if errNumb == 2 and not os.path.exists(os.path.dirname(renamed[0])):
                try:
                    os.makedirs(os.path.dirname(renamed[0]))
                except OSError as error:
                    n = error.errno
                    err = error.strerror
                    self._show_rename_error(i, err, original, renamed)
                    return 'makedirs'
                else:
                    return self._rename_item(i, original, renamed, refresh_int)
            else:
                self._show_rename_error(i, err, original, renamed)
                return True
        except OSError as error:
            errNumb = error.errno
            err = error.strerror
            app.debug_print("OSError : %s, %s" % (errNumb, err))
            # don't stop for a read-only error if the renamed item exists
            if not (errNumb == 30 and os.path.exists(renamed[0])):
                self._show_rename_error(i, err, original, renamed)
                return True

        # set item as renamed
        main.toRename[i][1][1] = True

        # refresh based on user settings
        if i % refresh_int == 0:
            self._set_display(i)

        # renaming is successful
        return False

    def __compare(self, renamed, original):
        """Dupe checking, windows is case insensitive."""
        renamed = renamed[0]
        original = original[0]
        if platform.system() == 'Windows':
            renamed = renamed.lower()
            original = original.lower()
        if renamed != original:
            return True
        else:
            return False

    def __rename_item_list(self, event):
        """After pre-renaming checks are completed, rename the list of items."""
        # calculate refresh settings
        count = len(main.toRename)
        count = count / 25 + 1
        if count > int(app.prefs.get('renRefreshMin')):
            count = int(app.prefs.get('renRefreshMin'))

        # define here for faster processing
        def exists(item):
            return os.path.exists(item)
        def join(a, b, c):
            return os.path.join(a, b, c)

        warn = False
        if event != u'undo':
            path = main.picker.params.root

        # renaming operation:
        i = 0
        for original, renamed in main.toRename:
            if warn != 'duplicate_name' and self.__compare(renamed, original) and\
                exists(renamed[0]):
                    # set item as bad
                    main.toRename[i][1][1] = None
                    self._set_display(i)
                    main.set_status_msg(_(u"Duplicate name"), u'warn')
                    msg = _(u"This name already exists:\n%s") % renamed[0]\
                        + _(u"\n\nI can make a sub-folder called 't_e_m_p' and do the renaming operation there.\nYou can then move everything back.\n\nGo ahead and do this?")
                    title = _(u"Duplicate name")
                    if utils.make_yesno_dlg(msg, title):
                        warn = 'duplicate_name'
                    else:
                        error = True
                        break
            # set correct path if in dupe error mode
            if warn == 'duplicate_name':
                if not path.endswith(os.sep):
                    path = path + os.sep
                renamed[0] = renamed[0].replace(path, u'')
                renamed[0] = join(path, u't_e_m_p', renamed[0])

            # the actual renaimg op
            error = self._rename_item(i, original, renamed, count)

            if error:
                break
            i += 1
            app.debug_print("%s\n%s\n" % (original[0], renamed[0]))

        main.set_status_msg(_(u"Writing undo files, please wait ..."), u'wait')
        # write out undo files
        backup = main.toRename[:i]
        if app.recursiveFolderOn:
            backup.reverse()
        for original, renamed in backup:
            self.originalFile.write(original[0] + u'\n')
            self.renamedFile.write(renamed[0] + u'\n')
        return error, i

    def _print_list(list):
        """Print out a list (for testing/debug)."""
        for item in list:
            print(item)

    def rename(self, event):
        """
        Write undo files first (safety first !), then attemp to perform
        the renaming operation.
        """
        itemsRenamed = 0
        error = False
        main.currentItem = None
        main.bottomWindow.display.mode = 'rename'
        utils.set_busy(True)
        main.picker.view.path.SetEditable(False)

        # adjust and sort items when recursively renaming folders
        if app.recursiveFolderOn and event != u'undo':
            main.set_status_msg(_(u"Adjusting %s recursive paths, please wait ...") % len(main.toRename), u'wait')

            progressDialog = classes.ProgressDialog(main, app.prefs, main.items,
                                                    _(u"Adjusting %%% recursive paths, please wait ..."))

            if app.showTimes:
                t = time.time()

            def sort_test(n):
                return -n[1][0].count(os.sep)

            main.toRename.sort(key=sort_test)

            progressDialog.destroy()

            if app.showTimes:
                print("%s items recursive adjust : %s" % (len(main.toRename), (time.time() - t)))

        if not error:
            main.set_status_msg(_(u"Renaming in progress, please wait ..."), u'wait')

            # open undo files for writing
            try:
                self.originalFile = codecs.open(utils.get_user_path(u'undo/original.bak'), 'w', "utf-8")
                self.renamedFile = codecs.open(utils.get_user_path(u'undo/renamed.bak'), 'w', "utf-8")
            except IOError as error:
                n = error.errno
                strerror = error.strerror
                msg = strerror + _(u"\nMake sure 'undo' directory exists and is read/write\n\nYou will not be able to undo!!\nDo you want to continue??")
                title = _(u"Problem with undo!")
                if not utils.make_yesno_dlg(msg, title):
                    error = 'cancelled'
                dlg.Destroy()

        # enough checking, DO IT !!
        if not error:
            if app.showTimes:
                t = time.time()
            # rename the item list
            error, itemsRenamed = self.__rename_item_list(event)

        # end of operations
        if not error:
            main.set_status_msg(_(u"Renaming for %s items completed")
                                % itemsRenamed, u"complete")
            if app.prefs.get('reloadAfterRename') and event != u'undo':
                main.picker.refresh(event)
            else:
                main.picker.clear_all()
            if app.prefs.get(u'alwaysMakeLog'):
                main.save_items_as_text(False)
        elif error == 'cancelled':
            main.set_status_msg(_(u"Renaming cancelled"), u'failed')

        utils.set_busy(False)
        self._set_display(len(main.toRename)-1)

        if app.showTimes:
            print("%s items renamed : %s" % (itemsRenamed, (time.time() - t)))

        # auto
        if app.autoModeLevel > 2 and not error:
            print(_(u"Renaming for %s items completed") % itemsRenamed)
            sys.exit()

        main.picker.refresh_dir_tree()

        main.bottomWindow.go.Enable(False)
        main.menuFile.GoMenu.Enable(False)
        if event != 'undo':
            main.bottomWindow.set_undo_redo_type('undo')
        main.picker.view.path.SetEditable(True)

    def undo_last_rename(self, event):
        """
        Grabs names from .bak files and reverts them to their originals.

        Keep this separate from csv file functions for safety and stability.
        """

        original = []
        renamed = []
        utils.set_busy(True)
        try:
            originalFile = codecs.open(utils.get_user_path(u'undo/original.bak'), 'r',
                                       'utf-8')
            renamedFile = codecs.open(utils.get_user_path(u'undo/renamed.bak'), 'r',
                                      'utf-8')
            for line in originalFile:
                original.append([line.strip(), False])
            for line in renamedFile:
                renamed.append([line.strip(), 1])

        except IOError as error:
            utils.make_err_msg(_(u"%s\n\nUndo Failed !!") % error, _(u"Error"))
            pass
        else:
            def get_name(x): return x[0]
            commonPrefix = os.path.commonprefix(map(get_name, original)).rstrip(os.sep)
            if os.path.exists(commonPrefix):
                main.picker.view.path.SetValue(commonPrefix)
                main.picker.view.dirPicker.SetPath(commonPrefix)

            if not len(original) == 0:
                main.toRename = list(zip(renamed, original))#reverse order from original rename!
                main.currentItem = None
                main.display_results()
                main.rename_items(u'undo')
                main.menuFile.SaveLog.Enable(False)
            else:
                main.set_status_msg(_(u"Nothing to undo"), u'eyes')

        main.bottomWindow.set_undo_redo_type('check')
        utils.set_busy(False)
